---
title: "Report: Body-sites microbiome in animal model"
subtitle: "Part 1: Body-sites microbiome SparCC"
author: "Aurea Simon-Soro"
date: \today
output:
  pdf_document: default
  html_document: default
---


Sparse and Compositionally Robust Inference of Microbial Ecological Networks
https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004226#sec002
https://science.sciencemag.org/content/365/6449/eaau4735.long
https://rdrr.io/github/zdk123/SpiecEasi/f/README.Rmd
QIIME: https://forum.qiime2.org/t/q2-scnic-a-tool-for-making-correlation-networks-finding-modules-of-observations-and-summarizing-them/6116

```{r}
library(SpiecEasi)

```

#Oral Swabs
```{r case Oral}

# Subset to case Oral Swab
case.Oral <- summed_cts[, which(grepl("Sw", colnames(summed_cts)))]
# Filter out OTUs that have less than 2 reads on average
case.Oral <- case.Oral[-which(rowMeans(case.Oral) < 2),]
#write.table(case.Oral, "case_Oral_filtered.txt", sep = "\t")
```


```{r SparCC first approach}
#Run SparCC on the samples for true correlation coefficients
#sparcc.OralSwab<- sparcc(case.Oral, iter = 20, inner_iter = 10, th = 0.1)
```

##New analysis for Oral Swab
```{r}
#We need the matrix containing non-normalized OTU wit samples in rows and feature OTU in columns
case.Oral<- t(case.Oral)

#method mb
se.mb.oral <- spiec.easi(case.Oral, method='mb', lambda.min.ratio=1e-2,
                          nlambda=20, pulsar.params=list(rep.num=50))
#method glasso
se.gl.oral <- spiec.easi(case.Oral, method='glasso', lambda.min.ratio=1e-2,
                          nlambda=20, pulsar.params=list(rep.num=50))

sparcc.oral <- sparcc(case.Oral)
## Define arbitrary threshold for SparCC correlation matrix for the graph
sparcc.graph <- abs(sparcc.oral$Cor) >= 0.3
diag(sparcc.graph) <- 0
library(Matrix)
sparcc.graph <- Matrix(sparcc.graph, sparse=TRUE)
## Create igraph objects
ig.mb     <- adj2igraph(getRefit(se.mb.oral))
ig.gl     <- adj2igraph(getRefit(se.gl.oral))
ig.sparcc <- adj2igraph(sparcc.graph)
```

##Visualize using igraph plotting
```{r}
library(igraph)
## set size of vertex proportional to clr-mean
vsize    <- rowMeans(clr(case.Oral, 1))+6
am.coord <- layout.fruchterman.reingold(ig.mb)
label<- rownames(clr(case.Oral, 2)) %>%
  as.data.frame(case.Oral)

label<- separate(label, ., sep=" ", c("Taxon","Taxon_name"))  # Splits the taxon name column by the 'space' into "Taxon" and "Taxon_name"
label$Taxon_name <- substring(label$Taxon_name, 4)# Removes the g__ or f__ in the Taxon_name column


par(mfrow=c(1,3))
plot(ig.mb, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="MB")
plot(ig.gl, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="glasso")
plot(ig.sparcc, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="sparcc", color=s$study_group)
```
##Stats
We can evaluate the weights on edges networks using the terms from the underlying model. SparCC correlations can be used directly, while SpiecEasi networks need to be massaged a bit. Note that since SPIEC-EASI is based on penalized estimators, the edge weights are not directly comparable to SparCC (or Pearson/Spearman correlation coefficients)
```{r}

secor  <- cov2cor(getOptCov(se.gl.oral))
sebeta <- symBeta(getOptBeta(se.mb.oral), mode='maxabs')
elist.gl     <- summary(triu(secor*getRefit(se.gl.oral), k=1))
elist.mb     <- summary(sebeta)
elist.sparcc <- summary(sparcc.graph*sparcc.oral$Cor)

hist(elist.sparcc[,3], main='', xlab='edge weights')
hist(elist.mb[,3], add=TRUE, col='forestgreen')
hist(elist.gl[,3], add=TRUE, col='red')
```

##Stats degree
Lets look at the degree statistics from the networks inferred by each method.
```{r}
dd.gl     <- degree.distribution(ig.gl)
dd.mb     <- degree.distribution(ig.mb)
dd.sparcc <- degree.distribution(ig.sparcc)

plot(0:(length(dd.sparcc)-1), dd.sparcc, ylim=c(0,.35), type='b',
      ylab="Frequency", xlab="Degree", main="Degree Distributions")
points(0:(length(dd.gl)-1), dd.gl, col="red" , type='b')
points(0:(length(dd.mb)-1), dd.mb, col="forestgreen", type='b')
legend("topright", c("MB", "glasso", "sparcc"),
        col=c("forestgreen", "red", "black"), pch=1, lty=1)
```

#-----------------------
#Feces
```{r case Feces}

# Subset to case Feces 
case.Feces <- summed_cts[, which(grepl("Sw", colnames(summed_cts)))]
# Filter out OTUs that have less than 2 reads on average
case.Feces <- case.Feces[-which(rowMeans(case.Feces) < 2),]
#write.table(case.Feces, "case_Feces_filtered.txt", sep = "\t")
```


```{r SparCC first approach}
#Run SparCC on the samples for true correlation coefficients
#sparcc.FecesSwab<- sparcc(case.Feces, iter = 20, inner_iter = 10, th = 0.1)
```

##New analysis for Feces
```{r}
#We need the matrix containing non-normalized OTU wit samples in rows and feature OTU in columns
case.Feces<- t(case.Feces)

#method mb
se.mb.Feces <- spiec.easi(case.Feces, method='mb', lambda.min.ratio=1e-2,
                          nlambda=20, pulsar.params=list(rep.num=50))
#method glasso
se.gl.Feces <- spiec.easi(case.Feces, method='glasso', lambda.min.ratio=1e-2,
                          nlambda=20, pulsar.params=list(rep.num=50))

sparcc.Feces <- sparcc(case.Feces)
## Define arbitrary threshold for SparCC correlation matrix for the graph
sparcc.graph <- abs(sparcc.Feces$Cor) >= 0.3
diag(sparcc.graph) <- 0
library(Matrix)
sparcc.graph <- Matrix(sparcc.graph, sparse=TRUE)
## Create igraph objects
ig.mb     <- adj2igraph(getRefit(se.mb.Feces))
ig.gl     <- adj2igraph(getRefit(se.gl.Feces))
ig.sparcc <- adj2igraph(sparcc.graph)
```

##Visualize using igraph plotting
```{r}
library(igraph)
## set size of vertex proportional to clr-mean
vsize    <- rowMeans(clr(case.Feces, 1))+6
am.coord <- layout.fruchterman.reingold(ig.mb)
label<- rownames(clr(case.Feces, 1)) %>%
  as.data.frame(case.Oral)

label<- separate(label, ., sep=" ", c("Taxon","Taxon_name"))  # Splits the taxon name column by the 'space' into "Taxon" and "Taxon_name"
label$Taxon_name <- substring(label$Taxon_name, 4)# Removes the g__ or f__ in the Taxon_name column
  
par(mfrow=c(1,3))
plot(ig.mb, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="MB")
plot(ig.gl, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="glasso")
plot(ig.sparcc, layout=am.coord, vertex.size=vsize, vertex.label=label$Taxon_name, main="sparcc")
```
##Stats
We can evaluate the weights on edges networks using the terms from the underlying model. SparCC correlations can be used directly, while SpiecEasi networks need to be massaged a bit. Note that since SPIEC-EASI is based on penalized estimators, the edge weights are not directly comparable to SparCC (or Pearson/Spearman correlation coefficients)
```{r}

secor  <- cov2cor(getOptCov(se.gl.Feces))
sebeta <- symBeta(getOptBeta(se.mb.Feces), mode='maxabs')
elist.gl     <- summary(triu(secor*getRefit(se.gl.Feces), k=1))
elist.mb     <- summary(sebeta)
elist.sparcc <- summary(sparcc.graph*sparcc.Feces$Cor)

hist(elist.sparcc[,3], main='', xlab='edge weights')
hist(elist.mb[,3], add=TRUE, col='forestgreen')
hist(elist.gl[,3], add=TRUE, col='red')
```

##Stats degree
Lets look at the degree statistics from the networks inferred by each method.
```{r}
dd.gl     <- degree.distribution(ig.gl)
dd.mb     <- degree.distribution(ig.mb)
dd.sparcc <- degree.distribution(ig.sparcc)

plot(0:(length(dd.sparcc)-1), dd.sparcc, ylim=c(0,.35), type='b',
      ylab="Frequency", xlab="Degree", main="Degree Distributions")
points(0:(length(dd.gl)-1), dd.gl, col="red" , type='b')
points(0:(length(dd.mb)-1), dd.mb, col="forestgreen", type='b')
legend("topright", c("MB", "glasso", "sparcc"),
        col=c("forestgreen", "red", "black"), pch=1, lty=1)
```